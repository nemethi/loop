#!/bin/bash

COMMAND=""
EXIT_CODES=()
TIMEOUT=""
SLEEP=""

print_help() {
cat << HELP
  Loop the specified command until it exits with one of the specified exit codes.
  The exit code '0' is implicitly included.
  Additionally, a timeout value may be supplied.
  Setting the timeout to '0' has the same effect as not supplying it.
  The sleep option may be used to make the script wait before executing the command again.

  Usage: loop <-c command> [-t timeout][-e exit codes][-s sleep duration]

  Examples:
    loop -c "curl https://www.google.com"             -- Call curl until it exits with 0.
    loop -c "wget https://www.google.com" -e "4 5 6"  -- Call wget until it exits with 0, 4, 5 or 6.
    loop -c "traceroute google.com" -s 3              -- Call traceroute until it exits with 0,
                                                         "sleeping" 3 seconds between each call.
    loop -c "ping https://www.google.com" -t 20 -e 1  -- Call ping until it exits with 0 or 1, or 20 seconds has passed.

  Exit codes:
    In normal cases, loop exits with the exit code returned by the specified command.
    However, there are two special exit codes returned by loop:
      101 – loop was called with an invalid option or with the -h option
      102 – a timeout occurred
HELP
}

main() {
  set_options "$@"
  loop_command
}

set_options() {
  while getopts ':c:t:e:s:h' opt; do
    case ${opt} in
      c) COMMAND="${OPTARG}" ;;
      t) TIMEOUT="${OPTARG}" ;;
      e) EXIT_CODES=("${OPTARG}") ;;
      s) SLEEP="${OPTARG}" ;;
      h) print_help && exit 101 ;;
      \?|*) print_help && exit 101 ;;
    esac
  done

  validate_options
}

loop_command() {
  local finished=1
  local exit_code=0
  local timed_out=1
  local deadline=$(($(date +%s) + TIMEOUT))

  until [[ ${timed_out} -eq 0 || ${finished} -eq 0 ]]; do
    ${BASH} -c "${COMMAND}"
    exit_code=$?
    sleep "${SLEEP}"
    finished=$(exit_code_matches ${exit_code})
    timed_out=$(get_timed_out_value ${deadline})
  done

  if [[ ${timed_out} -eq 0 ]]; then
    exit 102
  else
    exit ${exit_code}
  fi
}

exit_code_matches() {
  local code="$1"
  if [[ ${EXIT_CODES[*]} =~ ${code} ]]; then
    echo 0
  else
    echo 1
  fi
}

get_timed_out_value() {
  local deadline="$1"
  if [[ ${TIMEOUT} -ne 0 ]]; then
    is_timed_out "${deadline}"
  else
    echo 1
  fi
}

is_timed_out() {
  local timed_out_time="$1"
  local current_time=$(date +%s)
  if [[ ${timed_out_time} -le ${current_time} ]]; then
    echo 0
  else
    echo 1
  fi
}

validate_options() {
  exit_on_missing_command
  set_default_timeout
  set_default_exit_code
  set_default_sleep
  prepare_exit_codes
  validate_numeric_params
}

exit_on_missing_command() {
  if [[ -z "${COMMAND}" ]]; then
    print_help
    exit 101
  fi
}

set_default_timeout() {
  if [[ -z "${TIMEOUT}" ]]; then
    TIMEOUT=0
  fi
}

set_default_exit_code() {
  if [[ -z "${EXIT_CODES[*]}" ]]; then
    EXIT_CODES=(0)
  fi
}

set_default_sleep() {
  if [[ -z "${SLEEP}" ]]; then
    SLEEP=0
  fi
}

prepare_exit_codes() {
  EXIT_CODES+=(0)
  mapfile -t EXIT_CODES < <(printf "%s\n" "${EXIT_CODES[@]}" | sort -u)
}

validate_numeric_params() {
  if ! is_number "${TIMEOUT}"; then
    echo "looper: Invalid value '${TIMEOUT}' for timeout."
    echo "looper: exiting"
    exit 101
  fi

  if ! is_number "${SLEEP}"; then
    echo "looper: Invalid value '${SLEEP}' for sleep."
    echo "looper: exiting"
    exit 101
  fi

  for elem in "${EXIT_CODES[@]}"; do
    if ! is_number "${elem}"; then
      echo "looper: Invalid value '${elem}' for exit code."
      echo "looper: exiting"
      exit 101
    fi
  done
}

is_number() {
  re='^(0|[1-9]+[0-9]*){1}$'
  if [[ $1 =~ $re ]]; then
    return 0
  else
    return 1
  fi
}

if [[ "${#BASH_SOURCE[@]}" -eq 1 ]]; then
    main "$@"
fi



